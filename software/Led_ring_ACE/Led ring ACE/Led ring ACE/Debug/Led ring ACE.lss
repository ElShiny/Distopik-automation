
Led ring ACE.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000000  00800100  00800100  0000049e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000042a  00000000  00000000  00000074  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000004c  00800100  00800100  0000049e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000049e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  000004d0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000138  00000000  00000000  0000050c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000014b5  00000000  00000000  00000644  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000b01  00000000  00000000  00001af9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000a66  00000000  00000000  000025fa  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000274  00000000  00000000  00003060  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000610  00000000  00000000  000032d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000007a4  00000000  00000000  000038e4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000100  00000000  00000000  00004088  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	61 c0       	rjmp	.+194    	; 0xc4 <__ctors_end>
   2:	7b c0       	rjmp	.+246    	; 0xfa <__bad_interrupt>
   4:	7a c0       	rjmp	.+244    	; 0xfa <__bad_interrupt>
   6:	22 c1       	rjmp	.+580    	; 0x24c <__vector_3>
   8:	78 c0       	rjmp	.+240    	; 0xfa <__bad_interrupt>
   a:	77 c0       	rjmp	.+238    	; 0xfa <__bad_interrupt>
   c:	76 c0       	rjmp	.+236    	; 0xfa <__bad_interrupt>
   e:	75 c0       	rjmp	.+234    	; 0xfa <__bad_interrupt>
  10:	74 c0       	rjmp	.+232    	; 0xfa <__bad_interrupt>
  12:	73 c0       	rjmp	.+230    	; 0xfa <__bad_interrupt>
  14:	72 c0       	rjmp	.+228    	; 0xfa <__bad_interrupt>
  16:	71 c0       	rjmp	.+226    	; 0xfa <__bad_interrupt>
  18:	70 c0       	rjmp	.+224    	; 0xfa <__bad_interrupt>
  1a:	6f c0       	rjmp	.+222    	; 0xfa <__bad_interrupt>
  1c:	6e c0       	rjmp	.+220    	; 0xfa <__bad_interrupt>
  1e:	6d c0       	rjmp	.+218    	; 0xfa <__bad_interrupt>
  20:	6c c0       	rjmp	.+216    	; 0xfa <__bad_interrupt>
  22:	6b c0       	rjmp	.+214    	; 0xfa <__bad_interrupt>
  24:	6a c0       	rjmp	.+212    	; 0xfa <__bad_interrupt>
  26:	69 c0       	rjmp	.+210    	; 0xfa <__bad_interrupt>

00000028 <__trampolines_end>:
  28:	00 c2       	rjmp	.+1024   	; 0x42a <_etext>
  2a:	01 00       	.word	0x0001	; ????
  2c:	01 00       	.word	0x0001	; ????
  2e:	05 00       	.word	0x0005	; ????
  30:	05 00       	.word	0x0005	; ????
  32:	03 00       	.word	0x0003	; ????
  34:	00 e1       	ldi	r16, 0x10	; 16
  36:	00 00       	nop
  38:	01 00       	.word	0x0001	; ????
  3a:	0f 00       	.word	0x000f	; ????
  3c:	0f 00       	.word	0x000f	; ????
  3e:	0d 00       	.word	0x000d	; ????
  40:	00 96       	adiw	r24, 0x00	; 0
  42:	00 00       	nop
  44:	02 00       	.word	0x0002	; ????
  46:	19 00       	.word	0x0019	; ????
  48:	1a 00       	.word	0x001a	; ????
  4a:	17 00       	.word	0x0017	; ????
  4c:	12 7a       	andi	r17, 0xA2	; 162
  4e:	00 00       	nop
  50:	07 00       	.word	0x0007	; ????
  52:	20 00       	.word	0x0020	; ????
  54:	21 00       	.word	0x0021	; ????
  56:	1d 00       	.word	0x001d	; ????
  58:	80 70       	andi	r24, 0x00	; 0
  5a:	00 00       	nop
  5c:	0b 00       	.word	0x000b	; ????
  5e:	23 00       	.word	0x0023	; ????
  60:	23 00       	.word	0x0023	; ????
  62:	20 00       	.word	0x0020	; ????
  64:	00 4b       	sbci	r16, 0xB0	; 176
  66:	00 00       	nop
  68:	14 00       	.word	0x0014	; ????
  6a:	37 00       	.word	0x0037	; ????
  6c:	37 00       	.word	0x0037	; ????
  6e:	34 00       	.word	0x0034	; ????
  70:	40 38       	cpi	r20, 0x80	; 128
  72:	00 00       	nop
  74:	1e 00       	.word	0x001e	; ????
  76:	4b 00       	.word	0x004b	; ????
  78:	4b 00       	.word	0x004b	; ????
  7a:	48 00       	.word	0x0048	; ????
  7c:	80 25       	eor	r24, r0
  7e:	00 00       	nop
  80:	32 00       	.word	0x0032	; ????
  82:	72 00       	.word	0x0072	; ????
  84:	72 00       	.word	0x0072	; ????
  86:	70 00       	.word	0x0070	; ????
  88:	c0 12       	cpse	r12, r16
  8a:	00 00       	nop
  8c:	6e 00       	.word	0x006e	; ????
  8e:	e9 00       	.word	0x00e9	; ????
  90:	e9 00       	.word	0x00e9	; ????
  92:	e6 00       	.word	0x00e6	; ????
  94:	60 09       	sbc	r22, r0
  96:	00 00       	nop
  98:	e5 00       	.word	0x00e5	; ????
  9a:	d8 01       	movw	r26, r16
  9c:	d8 01       	movw	r26, r16
  9e:	d5 01       	movw	r26, r10
  a0:	b0 04       	cpc	r11, r0
  a2:	00 00       	nop
  a4:	d3 01       	movw	r26, r6
  a6:	b4 03       	fmuls	r19, r20
  a8:	b4 03       	fmuls	r19, r20
  aa:	b1 03       	fmuls	r19, r17
  ac:	58 02       	muls	r21, r24
  ae:	00 00       	nop
  b0:	b4 03       	fmuls	r19, r20
  b2:	67 07       	cpc	r22, r23
  b4:	67 07       	cpc	r22, r23
  b6:	62 07       	cpc	r22, r18
  b8:	2c 01       	movw	r4, r24
  ba:	00 00       	nop
  bc:	67 07       	cpc	r22, r23
  be:	dd 0e       	add	r13, r29
  c0:	dd 0e       	add	r13, r29
  c2:	da 0e       	add	r13, r26

000000c4 <__ctors_end>:
  c4:	11 24       	eor	r1, r1
  c6:	1f be       	out	0x3f, r1	; 63
  c8:	cf ef       	ldi	r28, 0xFF	; 255
  ca:	d2 e0       	ldi	r29, 0x02	; 2
  cc:	de bf       	out	0x3e, r29	; 62
  ce:	cd bf       	out	0x3d, r28	; 61

000000d0 <__do_copy_data>:
  d0:	11 e0       	ldi	r17, 0x01	; 1
  d2:	a0 e0       	ldi	r26, 0x00	; 0
  d4:	b1 e0       	ldi	r27, 0x01	; 1
  d6:	ea e2       	ldi	r30, 0x2A	; 42
  d8:	f4 e0       	ldi	r31, 0x04	; 4
  da:	02 c0       	rjmp	.+4      	; 0xe0 <__do_copy_data+0x10>
  dc:	05 90       	lpm	r0, Z+
  de:	0d 92       	st	X+, r0
  e0:	a0 30       	cpi	r26, 0x00	; 0
  e2:	b1 07       	cpc	r27, r17
  e4:	d9 f7       	brne	.-10     	; 0xdc <__do_copy_data+0xc>

000000e6 <__do_clear_bss>:
  e6:	21 e0       	ldi	r18, 0x01	; 1
  e8:	a0 e0       	ldi	r26, 0x00	; 0
  ea:	b1 e0       	ldi	r27, 0x01	; 1
  ec:	01 c0       	rjmp	.+2      	; 0xf0 <.do_clear_bss_start>

000000ee <.do_clear_bss_loop>:
  ee:	1d 92       	st	X+, r1

000000f0 <.do_clear_bss_start>:
  f0:	ac 34       	cpi	r26, 0x4C	; 76
  f2:	b2 07       	cpc	r27, r18
  f4:	e1 f7       	brne	.-8      	; 0xee <.do_clear_bss_loop>
  f6:	9f d0       	rcall	.+318    	; 0x236 <main>
  f8:	96 c1       	rjmp	.+812    	; 0x426 <_exit>

000000fa <__bad_interrupt>:
  fa:	82 cf       	rjmp	.-252    	; 0x0 <__vectors>

000000fc <ACEInit>:
#include <avr/io.h>


void ACEInit(void){
	
	DDRB &= ~(0x03); //set ace pins on portx to input
  fc:	84 b1       	in	r24, 0x04	; 4
  fe:	8c 7f       	andi	r24, 0xFC	; 252
 100:	84 b9       	out	0x04, r24	; 4
	DDRC &= ~(0x87);
 102:	87 b1       	in	r24, 0x07	; 7
 104:	88 77       	andi	r24, 0x78	; 120
 106:	87 b9       	out	0x07, r24	; 7
	DDRD = 0x08; //set EN to output
 108:	88 e0       	ldi	r24, 0x08	; 8
 10a:	8a b9       	out	0x0a, r24	; 10
	
	PORTD |= 1<<ACE_EN;
 10c:	8b b1       	in	r24, 0x0b	; 11
 10e:	88 60       	ori	r24, 0x08	; 8
 110:	8b b9       	out	0x0b, r24	; 11
 112:	08 95       	ret

00000114 <I2CInit>:
#define BITRATE 10                             // Hardware I2C bitrate
#define PRESCALER 0							// SET PRESCALER TO 1


void I2CInit(void){
  TWBR = BITRATE;
 114:	8a e0       	ldi	r24, 0x0A	; 10
 116:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7fe0b8>
  TWSR &= ~(0x2 & PRESCALER);
 11a:	e9 eb       	ldi	r30, 0xB9	; 185
 11c:	f0 e0       	ldi	r31, 0x00	; 0
 11e:	80 81       	ld	r24, Z
 120:	80 83       	st	Z, r24
 122:	08 95       	ret

00000124 <I2CStart>:
}

// Start transmission by sending address
uint8_t I2CStart (uint8_t address, uint8_t rw) {

	TWCR |= 1<<TWINT | 1<<TWSTA | 1<<TWEN;		//send start 
 124:	ec eb       	ldi	r30, 0xBC	; 188
 126:	f0 e0       	ldi	r31, 0x00	; 0
 128:	90 81       	ld	r25, Z
 12a:	94 6a       	ori	r25, 0xA4	; 164
 12c:	90 83       	st	Z, r25
	while (!(TWCR & (1<<TWINT)));				//wait for start flag
 12e:	90 91 bc 00 	lds	r25, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7fe0bc>
 132:	99 23       	and	r25, r25
 134:	e4 f7       	brge	.-8      	; 0x12e <I2CStart+0xa>
	if ((TWSR & 0xF8) != 1<<TWS3 && (TWSR & 0xF8) != 1<<TWS4) return 1;	//check start status
 136:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7fe0b9>
 13a:	98 7f       	andi	r25, 0xF8	; 248
 13c:	98 30       	cpi	r25, 0x08	; 8
 13e:	29 f0       	breq	.+10     	; 0x14a <I2CStart+0x26>
 140:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7fe0b9>
 144:	98 7f       	andi	r25, 0xF8	; 248
 146:	90 31       	cpi	r25, 0x10	; 16
 148:	c9 f4       	brne	.+50     	; 0x17c <I2CStart+0x58>
	TWDR = address<<1 | rw;						//write adr+rw
 14a:	90 e0       	ldi	r25, 0x00	; 0
 14c:	88 0f       	add	r24, r24
 14e:	99 1f       	adc	r25, r25
 150:	86 2b       	or	r24, r22
 152:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7fe0bb>
	TWCR = 1<<TWINT | 1<<TWEN;					//proceed
 156:	84 e8       	ldi	r24, 0x84	; 132
 158:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7fe0bc>
	while (!(TWCR & (1<<TWINT)));				//wait for send
 15c:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7fe0bc>
 160:	88 23       	and	r24, r24
 162:	e4 f7       	brge	.-8      	; 0x15c <I2CStart+0x38>
	if (((TWSR & 0xF8) != (1<<TWS4|1<<TWS3)) &&
 164:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7fe0b9>
 168:	88 7f       	andi	r24, 0xF8	; 248
 16a:	88 31       	cpi	r24, 0x18	; 24
 16c:	49 f0       	breq	.+18     	; 0x180 <I2CStart+0x5c>
	((TWSR & 0xF8) != 1<<TWS6)) return 1;	//check if sent correctly
 16e:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7fe0b9>
	while (!(TWCR & (1<<TWINT)));				//wait for start flag
	if ((TWSR & 0xF8) != 1<<TWS3 && (TWSR & 0xF8) != 1<<TWS4) return 1;	//check start status
	TWDR = address<<1 | rw;						//write adr+rw
	TWCR = 1<<TWINT | 1<<TWEN;					//proceed
	while (!(TWCR & (1<<TWINT)));				//wait for send
	if (((TWSR & 0xF8) != (1<<TWS4|1<<TWS3)) &&
 172:	88 7f       	andi	r24, 0xF8	; 248
 174:	80 34       	cpi	r24, 0x40	; 64
 176:	31 f4       	brne	.+12     	; 0x184 <I2CStart+0x60>
	((TWSR & 0xF8) != 1<<TWS6)) return 1;	//check if sent correctly
	return 0;
 178:	80 e0       	ldi	r24, 0x00	; 0
 17a:	08 95       	ret
// Start transmission by sending address
uint8_t I2CStart (uint8_t address, uint8_t rw) {

	TWCR |= 1<<TWINT | 1<<TWSTA | 1<<TWEN;		//send start 
	while (!(TWCR & (1<<TWINT)));				//wait for start flag
	if ((TWSR & 0xF8) != 1<<TWS3 && (TWSR & 0xF8) != 1<<TWS4) return 1;	//check start status
 17c:	81 e0       	ldi	r24, 0x01	; 1
 17e:	08 95       	ret
	TWDR = address<<1 | rw;						//write adr+rw
	TWCR = 1<<TWINT | 1<<TWEN;					//proceed
	while (!(TWCR & (1<<TWINT)));				//wait for send
	if (((TWSR & 0xF8) != (1<<TWS4|1<<TWS3)) &&
	((TWSR & 0xF8) != 1<<TWS6)) return 1;	//check if sent correctly
	return 0;
 180:	80 e0       	ldi	r24, 0x00	; 0
 182:	08 95       	ret
	if ((TWSR & 0xF8) != 1<<TWS3 && (TWSR & 0xF8) != 1<<TWS4) return 1;	//check start status
	TWDR = address<<1 | rw;						//write adr+rw
	TWCR = 1<<TWINT | 1<<TWEN;					//proceed
	while (!(TWCR & (1<<TWINT)));				//wait for send
	if (((TWSR & 0xF8) != (1<<TWS4|1<<TWS3)) &&
	((TWSR & 0xF8) != 1<<TWS6)) return 1;	//check if sent correctly
 184:	81 e0       	ldi	r24, 0x01	; 1
	return 0;

}
 186:	08 95       	ret

00000188 <I2CStop>:

void I2CStop (void) {
	TWCR = 1<<TWINT|1<<TWSTO|1<<TWEN;	// Send STOP
 188:	84 e9       	ldi	r24, 0x94	; 148
 18a:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7fe0bc>
 18e:	08 95       	ret

00000190 <I2CWrite>:
	//while (!(TWCR & (1<<TWINT)));		// Wait for bus to return to idle state
}

uint8_t I2CWrite (uint8_t data) {
  TWDR = data;
 190:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7fe0bb>
  TWCR = 1<<TWINT | 1 << TWEN;
 194:	84 e8       	ldi	r24, 0x84	; 132
 196:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7fe0bc>
  while (!(TWCR & 1<<TWINT));
 19a:	80 91 bc 00 	lds	r24, 0x00BC	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7fe0bc>
 19e:	88 23       	and	r24, r24
 1a0:	e4 f7       	brge	.-8      	; 0x19a <I2CWrite+0xa>
  if((TWSR & 0xF8) != (1<<TWS5|1<<TWS3)) return 1;
 1a2:	80 91 b9 00 	lds	r24, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7fe0b9>
 1a6:	88 7f       	andi	r24, 0xF8	; 248
 1a8:	88 32       	cpi	r24, 0x28	; 40
 1aa:	11 f0       	breq	.+4      	; 0x1b0 <I2CWrite+0x20>
 1ac:	81 e0       	ldi	r24, 0x01	; 1
 1ae:	08 95       	ret
  return 0;
 1b0:	80 e0       	ldi	r24, 0x00	; 0
  //return (TWSR & 0xF8);
}
 1b2:	08 95       	ret

000001b4 <LEDSetReg>:
	DDRC |= 1<<PINC3;
	PORTC |= 1<<PINC3;
	
}

uint8_t LEDSetReg(uint8_t adr, uint8_t val){
 1b4:	cf 93       	push	r28
 1b6:	df 93       	push	r29
 1b8:	c8 2f       	mov	r28, r24
 1ba:	d6 2f       	mov	r29, r22
	
	if(I2CStart(LED_ADR, I2C_WRITE)) return 1;
 1bc:	60 e0       	ldi	r22, 0x00	; 0
 1be:	84 e3       	ldi	r24, 0x34	; 52
 1c0:	b1 df       	rcall	.-158    	; 0x124 <I2CStart>
 1c2:	81 11       	cpse	r24, r1
 1c4:	0b c0       	rjmp	.+22     	; 0x1dc <LEDSetReg+0x28>
	if(I2CWrite(adr)) return 2;
 1c6:	8c 2f       	mov	r24, r28
 1c8:	e3 df       	rcall	.-58     	; 0x190 <I2CWrite>
 1ca:	81 11       	cpse	r24, r1
 1cc:	09 c0       	rjmp	.+18     	; 0x1e0 <LEDSetReg+0x2c>
	if(I2CWrite(val)) return 3;
 1ce:	8d 2f       	mov	r24, r29
 1d0:	df df       	rcall	.-66     	; 0x190 <I2CWrite>
 1d2:	c8 2f       	mov	r28, r24
 1d4:	81 11       	cpse	r24, r1
 1d6:	06 c0       	rjmp	.+12     	; 0x1e4 <LEDSetReg+0x30>
	I2CStop();
 1d8:	d7 df       	rcall	.-82     	; 0x188 <I2CStop>
	return 0;
 1da:	05 c0       	rjmp	.+10     	; 0x1e6 <LEDSetReg+0x32>
	
}

uint8_t LEDSetReg(uint8_t adr, uint8_t val){
	
	if(I2CStart(LED_ADR, I2C_WRITE)) return 1;
 1dc:	c1 e0       	ldi	r28, 0x01	; 1
 1de:	03 c0       	rjmp	.+6      	; 0x1e6 <LEDSetReg+0x32>
	if(I2CWrite(adr)) return 2;
 1e0:	c2 e0       	ldi	r28, 0x02	; 2
 1e2:	01 c0       	rjmp	.+2      	; 0x1e6 <LEDSetReg+0x32>
	if(I2CWrite(val)) return 3;
 1e4:	c3 e0       	ldi	r28, 0x03	; 3
	I2CStop();
	return 0;
}
 1e6:	8c 2f       	mov	r24, r28
 1e8:	df 91       	pop	r29
 1ea:	cf 91       	pop	r28
 1ec:	08 95       	ret

000001ee <LEDInit>:

#include "led_drv.h"
#include "I2C.h"


void LEDInit(void){
 1ee:	cf 93       	push	r28
 1f0:	df 93       	push	r29
	
	LEDSetReg(0xA0, 0x01);
 1f2:	61 e0       	ldi	r22, 0x01	; 1
 1f4:	80 ea       	ldi	r24, 0xA0	; 160
 1f6:	de df       	rcall	.-68     	; 0x1b4 <LEDSetReg>
	LEDSetReg(0xA1, 30);
 1f8:	6e e1       	ldi	r22, 0x1E	; 30
 1fa:	81 ea       	ldi	r24, 0xA1	; 161
 1fc:	db df       	rcall	.-74     	; 0x1b4 <LEDSetReg>

	for(int a = 0x90; a < 0x9E; a++){
 1fe:	c0 e9       	ldi	r28, 0x90	; 144
 200:	d0 e0       	ldi	r29, 0x00	; 0
 202:	04 c0       	rjmp	.+8      	; 0x20c <__DATA_REGION_LENGTH__+0xc>
		LEDSetReg(a, 100);
 204:	64 e6       	ldi	r22, 0x64	; 100
 206:	8c 2f       	mov	r24, r28
 208:	d5 df       	rcall	.-86     	; 0x1b4 <LEDSetReg>
void LEDInit(void){
	
	LEDSetReg(0xA0, 0x01);
	LEDSetReg(0xA1, 30);

	for(int a = 0x90; a < 0x9E; a++){
 20a:	21 96       	adiw	r28, 0x01	; 1
 20c:	ce 39       	cpi	r28, 0x9E	; 158
 20e:	d1 05       	cpc	r29, r1
 210:	cc f3       	brlt	.-14     	; 0x204 <__DATA_REGION_LENGTH__+0x4>
		LEDSetReg(a, 100);
	}
	
	
	
	LEDSetReg(0x01, 150);
 212:	66 e9       	ldi	r22, 0x96	; 150
 214:	81 e0       	ldi	r24, 0x01	; 1
 216:	ce df       	rcall	.-100    	; 0x1b4 <LEDSetReg>
	LEDSetReg(0x12, 150);
 218:	66 e9       	ldi	r22, 0x96	; 150
 21a:	82 e1       	ldi	r24, 0x12	; 18
 21c:	cb df       	rcall	.-106    	; 0x1b4 <LEDSetReg>
	LEDSetReg(0x23, 150);	
 21e:	66 e9       	ldi	r22, 0x96	; 150
 220:	83 e2       	ldi	r24, 0x23	; 35
 222:	c8 df       	rcall	.-112    	; 0x1b4 <LEDSetReg>
	
	DDRC |= 1<<PINC3;
 224:	87 b1       	in	r24, 0x07	; 7
 226:	88 60       	ori	r24, 0x08	; 8
 228:	87 b9       	out	0x07, r24	; 7
	PORTC |= 1<<PINC3;
 22a:	88 b1       	in	r24, 0x08	; 8
 22c:	88 60       	ori	r24, 0x08	; 8
 22e:	88 b9       	out	0x08, r24	; 8
	
}
 230:	df 91       	pop	r29
 232:	cf 91       	pop	r28
 234:	08 95       	ret

00000236 <main>:
#include "led_drv.h"


int main(void)
{
	softSerialBegin(9600);
 236:	60 e8       	ldi	r22, 0x80	; 128
 238:	75 e2       	ldi	r23, 0x25	; 37
 23a:	80 e0       	ldi	r24, 0x00	; 0
 23c:	90 e0       	ldi	r25, 0x00	; 0
 23e:	69 d0       	rcall	.+210    	; 0x312 <softSerialBegin>
	ACEInit();
 240:	5d df       	rcall	.-326    	; 0xfc <ACEInit>
	I2CInit();
 242:	68 df       	rcall	.-304    	; 0x114 <I2CInit>
	
	LEDInit();
 244:	d4 df       	rcall	.-88     	; 0x1ee <LEDInit>
	
}
 246:	80 e0       	ldi	r24, 0x00	; 0
 248:	90 e0       	ldi	r25, 0x00	; 0
 24a:	08 95       	ret

0000024c <__vector_3>:


//
// Interrupt handling, receive routine
//
ISR(PCINT0_vect) {
 24c:	1f 92       	push	r1
 24e:	0f 92       	push	r0
 250:	0f b6       	in	r0, 0x3f	; 63
 252:	0f 92       	push	r0
 254:	11 24       	eor	r1, r1
 256:	2f 93       	push	r18
 258:	3f 93       	push	r19
 25a:	4f 93       	push	r20
 25c:	8f 93       	push	r24
 25e:	9f 93       	push	r25
 260:	ef 93       	push	r30
 262:	ff 93       	push	r31
	uint8_t d = 0;

	// If RX line is high, then we don't see any start bit
	// so interrupt is probably not for us
	if ( !rx_pin_read() ) {
 264:	1f 99       	sbic	0x03, 7	; 3
 266:	49 c0       	rjmp	.+146    	; 0x2fa <__vector_3+0xae>
		// Wait approximately 1/2 of a bit width to "center" the sample
		tunedDelay(_rx_delay_centering);
 268:	80 91 4a 01 	lds	r24, 0x014A	; 0x80014a <_rx_delay_centering>
 26c:	90 91 4b 01 	lds	r25, 0x014B	; 0x80014b <_rx_delay_centering+0x1>

/* static */
inline void tunedDelay(uint16_t delay) {
	uint8_t tmp = 0;

	asm volatile("sbiw    %0, 0x01 \n\t"
 270:	20 e0       	ldi	r18, 0x00	; 0
 272:	01 97       	sbiw	r24, 0x01	; 1
 274:	2f ef       	ldi	r18, 0xFF	; 255
 276:	8f 3f       	cpi	r24, 0xFF	; 255
 278:	92 07       	cpc	r25, r18
 27a:	d9 f7       	brne	.-10     	; 0x272 <__vector_3+0x26>
	if ( !rx_pin_read() ) {
		// Wait approximately 1/2 of a bit width to "center" the sample
		tunedDelay(_rx_delay_centering);

		// Read each of the 8 bits
		for (uint8_t i = 0x1; i; i <<= 1) {
 27c:	21 e0       	ldi	r18, 0x01	; 1

//
// Interrupt handling, receive routine
//
ISR(PCINT0_vect) {
	uint8_t d = 0;
 27e:	40 e0       	ldi	r20, 0x00	; 0
	if ( !rx_pin_read() ) {
		// Wait approximately 1/2 of a bit width to "center" the sample
		tunedDelay(_rx_delay_centering);

		// Read each of the 8 bits
		for (uint8_t i = 0x1; i; i <<= 1) {
 280:	12 c0       	rjmp	.+36     	; 0x2a6 <__vector_3+0x5a>
			tunedDelay(_rx_delay_intrabit);
 282:	80 91 48 01 	lds	r24, 0x0148	; 0x800148 <_rx_delay_intrabit>
 286:	90 91 49 01 	lds	r25, 0x0149	; 0x800149 <_rx_delay_intrabit+0x1>

/* static */
inline void tunedDelay(uint16_t delay) {
	uint8_t tmp = 0;

	asm volatile("sbiw    %0, 0x01 \n\t"
 28a:	30 e0       	ldi	r19, 0x00	; 0
 28c:	01 97       	sbiw	r24, 0x01	; 1
 28e:	3f ef       	ldi	r19, 0xFF	; 255
 290:	8f 3f       	cpi	r24, 0xFF	; 255
 292:	93 07       	cpc	r25, r19
 294:	d9 f7       	brne	.-10     	; 0x28c <__vector_3+0x40>
		tunedDelay(_rx_delay_centering);

		// Read each of the 8 bits
		for (uint8_t i = 0x1; i; i <<= 1) {
			tunedDelay(_rx_delay_intrabit);
			uint8_t noti = ~i;
 296:	82 2f       	mov	r24, r18
 298:	80 95       	com	r24
			if (rx_pin_read())
 29a:	1f 9b       	sbis	0x03, 7	; 3
 29c:	02 c0       	rjmp	.+4      	; 0x2a2 <__vector_3+0x56>
				d |= i;
 29e:	42 2b       	or	r20, r18
 2a0:	01 c0       	rjmp	.+2      	; 0x2a4 <__vector_3+0x58>
			else // else clause added to ensure function timing is ~balanced
				d &= noti;
 2a2:	48 23       	and	r20, r24
	if ( !rx_pin_read() ) {
		// Wait approximately 1/2 of a bit width to "center" the sample
		tunedDelay(_rx_delay_centering);

		// Read each of the 8 bits
		for (uint8_t i = 0x1; i; i <<= 1) {
 2a4:	22 0f       	add	r18, r18
 2a6:	21 11       	cpse	r18, r1
 2a8:	ec cf       	rjmp	.-40     	; 0x282 <__vector_3+0x36>
			else // else clause added to ensure function timing is ~balanced
				d &= noti;
		}

		// skip the stop bit
		tunedDelay(_rx_delay_stopbit);
 2aa:	80 91 46 01 	lds	r24, 0x0146	; 0x800146 <_rx_delay_stopbit>
 2ae:	90 91 47 01 	lds	r25, 0x0147	; 0x800147 <_rx_delay_stopbit+0x1>

/* static */
inline void tunedDelay(uint16_t delay) {
	uint8_t tmp = 0;

	asm volatile("sbiw    %0, 0x01 \n\t"
 2b2:	01 97       	sbiw	r24, 0x01	; 1
 2b4:	2f ef       	ldi	r18, 0xFF	; 255
 2b6:	8f 3f       	cpi	r24, 0xFF	; 255
 2b8:	92 07       	cpc	r25, r18
 2ba:	d9 f7       	brne	.-10     	; 0x2b2 <__vector_3+0x66>

		// skip the stop bit
		tunedDelay(_rx_delay_stopbit);

		// if buffer full, set the overflow flag and return
		if (((_receive_buffer_tail + 1) & _SS_RX_BUFF_MASK) != _receive_buffer_head) {  // circular buffer
 2bc:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <_receive_buffer_tail>
 2c0:	90 e0       	ldi	r25, 0x00	; 0
 2c2:	01 96       	adiw	r24, 0x01	; 1
 2c4:	8f 73       	andi	r24, 0x3F	; 63
 2c6:	99 27       	eor	r25, r25
 2c8:	20 91 00 01 	lds	r18, 0x0100	; 0x800100 <__DATA_REGION_ORIGIN__>
 2cc:	30 e0       	ldi	r19, 0x00	; 0
 2ce:	82 17       	cp	r24, r18
 2d0:	93 07       	cpc	r25, r19
 2d2:	69 f0       	breq	.+26     	; 0x2ee <__vector_3+0xa2>
			// save new data in buffer: tail points to where byte goes
			_receive_buffer[_receive_buffer_tail] = d; // save new byte
 2d4:	e0 91 01 01 	lds	r30, 0x0101	; 0x800101 <_receive_buffer_tail>
 2d8:	f0 e0       	ldi	r31, 0x00	; 0
 2da:	ee 5f       	subi	r30, 0xFE	; 254
 2dc:	fe 4f       	sbci	r31, 0xFE	; 254
 2de:	40 83       	st	Z, r20
			_receive_buffer_tail = (_receive_buffer_tail + 1) & _SS_RX_BUFF_MASK;  // circular buffer
 2e0:	80 91 01 01 	lds	r24, 0x0101	; 0x800101 <_receive_buffer_tail>
 2e4:	8f 5f       	subi	r24, 0xFF	; 255
 2e6:	8f 73       	andi	r24, 0x3F	; 63
 2e8:	80 93 01 01 	sts	0x0101, r24	; 0x800101 <_receive_buffer_tail>
 2ec:	06 c0       	rjmp	.+12     	; 0x2fa <__vector_3+0xae>
		} else {
			_buffer_overflow = true;
 2ee:	81 e0       	ldi	r24, 0x01	; 1
 2f0:	90 e0       	ldi	r25, 0x00	; 0
 2f2:	90 93 43 01 	sts	0x0143, r25	; 0x800143 <_buffer_overflow+0x1>
 2f6:	80 93 42 01 	sts	0x0142, r24	; 0x800142 <_buffer_overflow>
		}
	}
}
 2fa:	ff 91       	pop	r31
 2fc:	ef 91       	pop	r30
 2fe:	9f 91       	pop	r25
 300:	8f 91       	pop	r24
 302:	4f 91       	pop	r20
 304:	3f 91       	pop	r19
 306:	2f 91       	pop	r18
 308:	0f 90       	pop	r0
 30a:	0f be       	out	0x3f, r0	; 63
 30c:	0f 90       	pop	r0
 30e:	1f 90       	pop	r1
 310:	18 95       	reti

00000312 <softSerialBegin>:

//
// Public methods
//

void softSerialBegin(long speed) {
 312:	0f 93       	push	r16
 314:	1f 93       	push	r17
 316:	8b 01       	movw	r16, r22
 318:	9c 01       	movw	r18, r24
	unsigned i;

	_receive_buffer_head = _receive_buffer_tail = 0;
 31a:	10 92 01 01 	sts	0x0101, r1	; 0x800101 <_receive_buffer_tail>
 31e:	10 92 00 01 	sts	0x0100, r1	; 0x800100 <__DATA_REGION_ORIGIN__>
	_buffer_overflow = false;
 322:	10 92 43 01 	sts	0x0143, r1	; 0x800143 <_buffer_overflow+0x1>
 326:	10 92 42 01 	sts	0x0142, r1	; 0x800142 <_buffer_overflow>
	SERDDR |= (1<<TXPIN); // set TX for output
 32a:	84 b1       	in	r24, 0x04	; 4
 32c:	80 64       	ori	r24, 0x40	; 64
 32e:	84 b9       	out	0x04, r24	; 4
	SERDDR &= ~(1<<RXPIN); // set RX for input
 330:	84 b1       	in	r24, 0x04	; 4
 332:	8f 77       	andi	r24, 0x7F	; 127
 334:	84 b9       	out	0x04, r24	; 4
	SERPORT |= (1<<TXPIN)|(1<<RXPIN); // assumes no inverse logic
 336:	85 b1       	in	r24, 0x05	; 5
 338:	80 6c       	ori	r24, 0xC0	; 192
 33a:	85 b9       	out	0x05, r24	; 5

	for (i = 0; i < sizeof(table) / sizeof(table[0]); ++i) {
 33c:	80 e0       	ldi	r24, 0x00	; 0
 33e:	90 e0       	ldi	r25, 0x00	; 0
 340:	6b c0       	rjmp	.+214    	; 0x418 <__LOCK_REGION_LENGTH__+0x18>
		long baud = pgm_read_dword(&table[i].baud);
 342:	fc 01       	movw	r30, r24
 344:	ee 0f       	add	r30, r30
 346:	ff 1f       	adc	r31, r31
 348:	e8 0f       	add	r30, r24
 34a:	f9 1f       	adc	r31, r25
 34c:	ee 0f       	add	r30, r30
 34e:	ff 1f       	adc	r31, r31
 350:	ee 0f       	add	r30, r30
 352:	ff 1f       	adc	r31, r31
 354:	e8 5d       	subi	r30, 0xD8	; 216
 356:	ff 4f       	sbci	r31, 0xFF	; 255
 358:	45 91       	lpm	r20, Z+
 35a:	55 91       	lpm	r21, Z+
 35c:	65 91       	lpm	r22, Z+
 35e:	74 91       	lpm	r23, Z
		if (baud == speed) {
 360:	40 17       	cp	r20, r16
 362:	51 07       	cpc	r21, r17
 364:	62 07       	cpc	r22, r18
 366:	73 07       	cpc	r23, r19
 368:	09 f0       	breq	.+2      	; 0x36c <softSerialBegin+0x5a>
 36a:	55 c0       	rjmp	.+170    	; 0x416 <__LOCK_REGION_LENGTH__+0x16>
			_rx_delay_centering = pgm_read_word(&table[i].rx_delay_centering);
 36c:	9c 01       	movw	r18, r24
 36e:	22 0f       	add	r18, r18
 370:	33 1f       	adc	r19, r19
 372:	f9 01       	movw	r30, r18
 374:	e8 0f       	add	r30, r24
 376:	f9 1f       	adc	r31, r25
 378:	ee 0f       	add	r30, r30
 37a:	ff 1f       	adc	r31, r31
 37c:	ee 0f       	add	r30, r30
 37e:	ff 1f       	adc	r31, r31
 380:	e4 5d       	subi	r30, 0xD4	; 212
 382:	ff 4f       	sbci	r31, 0xFF	; 255
 384:	45 91       	lpm	r20, Z+
 386:	54 91       	lpm	r21, Z
 388:	50 93 4b 01 	sts	0x014B, r21	; 0x80014b <_rx_delay_centering+0x1>
 38c:	40 93 4a 01 	sts	0x014A, r20	; 0x80014a <_rx_delay_centering>
			_rx_delay_intrabit = pgm_read_word(&table[i].rx_delay_intrabit);
 390:	f9 01       	movw	r30, r18
 392:	e8 0f       	add	r30, r24
 394:	f9 1f       	adc	r31, r25
 396:	ee 0f       	add	r30, r30
 398:	ff 1f       	adc	r31, r31
 39a:	ee 0f       	add	r30, r30
 39c:	ff 1f       	adc	r31, r31
 39e:	e2 5d       	subi	r30, 0xD2	; 210
 3a0:	ff 4f       	sbci	r31, 0xFF	; 255
 3a2:	45 91       	lpm	r20, Z+
 3a4:	54 91       	lpm	r21, Z
 3a6:	50 93 49 01 	sts	0x0149, r21	; 0x800149 <_rx_delay_intrabit+0x1>
 3aa:	40 93 48 01 	sts	0x0148, r20	; 0x800148 <_rx_delay_intrabit>
			_rx_delay_stopbit = pgm_read_word(&table[i].rx_delay_stopbit);
 3ae:	f9 01       	movw	r30, r18
 3b0:	e8 0f       	add	r30, r24
 3b2:	f9 1f       	adc	r31, r25
 3b4:	ee 0f       	add	r30, r30
 3b6:	ff 1f       	adc	r31, r31
 3b8:	ee 0f       	add	r30, r30
 3ba:	ff 1f       	adc	r31, r31
 3bc:	e0 5d       	subi	r30, 0xD0	; 208
 3be:	ff 4f       	sbci	r31, 0xFF	; 255
 3c0:	45 91       	lpm	r20, Z+
 3c2:	54 91       	lpm	r21, Z
 3c4:	50 93 47 01 	sts	0x0147, r21	; 0x800147 <_rx_delay_stopbit+0x1>
 3c8:	40 93 46 01 	sts	0x0146, r20	; 0x800146 <_rx_delay_stopbit>
			_tx_delay = pgm_read_word(&table[i].tx_delay);
 3cc:	f9 01       	movw	r30, r18
 3ce:	e8 0f       	add	r30, r24
 3d0:	f9 1f       	adc	r31, r25
 3d2:	ee 0f       	add	r30, r30
 3d4:	ff 1f       	adc	r31, r31
 3d6:	ee 0f       	add	r30, r30
 3d8:	ff 1f       	adc	r31, r31
 3da:	ee 5c       	subi	r30, 0xCE	; 206
 3dc:	ff 4f       	sbci	r31, 0xFF	; 255
 3de:	85 91       	lpm	r24, Z+
 3e0:	94 91       	lpm	r25, Z
 3e2:	90 93 45 01 	sts	0x0145, r25	; 0x800145 <_tx_delay+0x1>
 3e6:	80 93 44 01 	sts	0x0144, r24	; 0x800144 <_tx_delay>
			// Set up RX interrupts, but only if we have a valid RX baud rate
			PCICR |= (1<<PCIE0);
 3ea:	e8 e6       	ldi	r30, 0x68	; 104
 3ec:	f0 e0       	ldi	r31, 0x00	; 0
 3ee:	80 81       	ld	r24, Z
 3f0:	81 60       	ori	r24, 0x01	; 1
 3f2:	80 83       	st	Z, r24
			PCMSK0 |= (1<<RXPIN);
 3f4:	eb e6       	ldi	r30, 0x6B	; 107
 3f6:	f0 e0       	ldi	r31, 0x00	; 0
 3f8:	80 81       	ld	r24, Z
 3fa:	80 68       	ori	r24, 0x80	; 128
 3fc:	80 83       	st	Z, r24
			tunedDelay(_tx_delay);
 3fe:	80 91 44 01 	lds	r24, 0x0144	; 0x800144 <_tx_delay>
 402:	90 91 45 01 	lds	r25, 0x0145	; 0x800145 <_tx_delay+0x1>

/* static */
inline void tunedDelay(uint16_t delay) {
	uint8_t tmp = 0;

	asm volatile("sbiw    %0, 0x01 \n\t"
 406:	20 e0       	ldi	r18, 0x00	; 0
 408:	01 97       	sbiw	r24, 0x01	; 1
 40a:	2f ef       	ldi	r18, 0xFF	; 255
 40c:	8f 3f       	cpi	r24, 0xFF	; 255
 40e:	92 07       	cpc	r25, r18
 410:	d9 f7       	brne	.-10     	; 0x408 <__LOCK_REGION_LENGTH__+0x8>
			_tx_delay = pgm_read_word(&table[i].tx_delay);
			// Set up RX interrupts, but only if we have a valid RX baud rate
			PCICR |= (1<<PCIE0);
			PCMSK0 |= (1<<RXPIN);
			tunedDelay(_tx_delay);
			sei();
 412:	78 94       	sei
			return;
 414:	05 c0       	rjmp	.+10     	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
	_buffer_overflow = false;
	SERDDR |= (1<<TXPIN); // set TX for output
	SERDDR &= ~(1<<RXPIN); // set RX for input
	SERPORT |= (1<<TXPIN)|(1<<RXPIN); // assumes no inverse logic

	for (i = 0; i < sizeof(table) / sizeof(table[0]); ++i) {
 416:	01 96       	adiw	r24, 0x01	; 1
 418:	8d 30       	cpi	r24, 0x0D	; 13
 41a:	91 05       	cpc	r25, r1
 41c:	08 f4       	brcc	.+2      	; 0x420 <__LOCK_REGION_LENGTH__+0x20>
 41e:	91 cf       	rjmp	.-222    	; 0x342 <softSerialBegin+0x30>
		}
	}

	// No valid rate found
	// Indicate an error
}
 420:	1f 91       	pop	r17
 422:	0f 91       	pop	r16
 424:	08 95       	ret

00000426 <_exit>:
 426:	f8 94       	cli

00000428 <__stop_program>:
 428:	ff cf       	rjmp	.-2      	; 0x428 <__stop_program>
